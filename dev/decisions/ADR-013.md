# ADR-013: Notebook integration strategy for MolSys-AI

## Date
2025-12-05

## Status
Accepted

## Context
MolSys-AI is expected to assist users who frequently work inside Jupyter-based
environments (JupyterLab, and later VS Code notebooks). Typical workflows in
the MolSys* ecosystem include:

- running MolSysMT/TopoMT/MolSysViewer pipelines interactively,
- iterating on analysis code,
- documenting results directly in notebooks.

We want MolSys-AI to:

- help design and execute workflows (e.g. "analyse PDB 1TCD pockets with TopoMT,
  rank them by polarity with MolSysMT, and visualise the most polar pocket with
  MolSysViewer"),
- generate code that can be executed in notebooks,
- optionally assist in organising that code into notebook cells.

However, allowing an AI agent to **modify the current notebook in place** has
implications for:

- safety (unexpected code execution, confusing edits),
- reproducibility (implicit state changes),
- UX (surprising cell insertions/changes).

We need a strategy that balances:

- a safe baseline that never modifies the active notebook, and
- a path to more powerful, in-place edits that are opt-in and auditable,
  initially targeting JupyterLab and possibly VS Code later.

## Decision

MolSys-AI will support **two levels** of notebook integration:

1. **Safe, out-of-place notebook generation (baseline, implemented now)**  
   - The agent generates a *new* notebook file (e.g. `workflow_*.ipynb`) that
     contains the proposed workflow (code + markdown).
   - The current notebook is not modified.
   - The user opens and executes the generated notebook manually.

2. **In-place notebook editing (advanced, future work)**  
   - The agent can propose modifications to the **current** notebook
     (inserting cells, appending code).
   - Any such edits must be:
     - explicitly triggered by the user (no automatic writes),
     - visually clear and reversible,
     - implemented via front-end APIs (JupyterLab, later VS Code) rather than
       opaque hacks.
   - For now, the API for in-place editing exists only as a placeholder and
     raises `NotImplementedError`.

The repository already provides:

- `agent.notebook.create_workflow_notebook(...)` as the safe path (implemented),
- `agent.notebook.inject_workflow_into_current_notebook(...)` as a placeholder
  for future in-place editing.

## Options considered

### 1. Only generate new notebooks (no in-place edits)

**Pros**
- Very safe: the current notebook is never touched.
- Simple to reason about and to test.
- Works uniformly across JupyterLab, classic notebook, and VS Code.

**Cons**
- Less convenient UX when the user wants to continue in the same notebook.
- Requires manual switching between notebooks.

### 2. Only support in-place edits

**Pros**
- Very convenient: the agent can "continue" the current analysis directly.
- Feels more like a true in-notebook assistant.

**Cons**
- Risky: accidental or confusing edits to the user's notebook.
- Strongly tied to specific front-ends (JupyterLab vs VS Code).
- Harder to debug and to guarantee deterministic behaviour.

### 3. Two-tier approach (chosen)

**Pros**
- Safe baseline (new notebooks) is always available.
- Clear path to more powerful features for advanced users.
- The API surface is defined early (`agent.notebook`), allowing code to grow
  without breaking callers.

**Cons**
- Slightly more complex API surface.
- Requires careful design of UX and safeguards for in-place editing later.

## Justification

The two-tier approach provides a robust compromise:

- It delivers immediate value:
  - `create_workflow_notebook` already writes valid `.ipynb` files from a list
    of `NotebookCellSpec`, allowing the agent to produce runnable workflows
    without touching the active notebook.
- It keeps the door open for richer experiences:
  - `inject_workflow_into_current_notebook` exists as a clearly named, explicit
    entrypoint for future JupyterLab/VS Code integration.
- It communicates clearly to users and developers:
  - "safe by default" is enforced, while more powerful features are opt-in and
    will be designed carefully (e.g. with explicit confirmation and visible
    changes).

## Consequences

- **Short term**
  - Notebook users can:
    - call MolSys-AI from Jupyter using `create_notebook_agent` +
      `NotebookChatSession`,
    - ask MolSys-AI to generate workflows that are written into new notebooks
      via `create_workflow_notebook`.
  - No function will modify the current notebook silently.

- **Medium term**
  - We will design and implement:
    - JupyterLab-specific helpers (e.g. small front-end extension or JS bridge)
      that can insert cells on user request,
    - corresponding VS Code integration if/when needed.
  - `inject_workflow_into_current_notebook` will be updated to use those
    front-end APIs, with appropriate safeguards.

- **Long term**
  - Advanced users will be able to choose:
    - "generate a new notebook with this workflow", or
    - "insert the proposed cells below this one" (with explicit confirmation).
  - This will make MolSys-AI a first-class assistant for interactive notebooks
    in the MolSys* ecosystem.

## Future notes

- Define the concrete workflow representation that the planner/executor will
  hand to the notebook helpers (e.g. a small DSL that describes steps +
  suggested cell content).
- Investigate JupyterLab and VS Code APIs for:
  - inserting and deleting cells,
  - annotating cells as "AI-generated",
  - providing undo/rollback capabilities.
- Consider security and auditability:
  - logging which cells were generated by the agent,
  - requiring explicit user confirmation before executing AI-generated code.

